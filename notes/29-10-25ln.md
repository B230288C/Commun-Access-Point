当$jobs = Job::all();，使用loop并 $jobs->company->name; 时会产生N+1问题，因为是关联模型的原因(belongsTo，hasMany etc)，
这是因为company没有包含在Job里面，只有真的查询的时候laravel才会去查询，这就是lazy-loading，laravel需要额外查询关联模型导致额外的性能消耗。解决方法就是 $jobs = Job::with('employer')->get(); ，这样可以把关联数据也预加载，就不会消耗额外的性能。
如果已经$jobs = Job::all(); ，那可以用$jobs->load('employer');
想要停止laravel的lazy-loading可以在AppServiceProvider的boot() function里存入 Model::preventLazyLoading();

当数据量多的时候可以用$jobs = Job::with('employer')->paginate(10);来页面显示数据，在显示的地方用{{$jobs->links()}}自动生成分页导航

想要custom这个paginate的话可以在bash输入$ php artisan vendor:publish 然后选择laravel-pagination，laravel会复制这个去到本地目录

collection类$jobs = Job::all();用的是load()，模型类Job::factory()->count(10)->create()可以用factory()

database的seeder是把factory的东西都集中到这里进行批量处理

路径是按顺序的所以wildcard必须放在所有静态或者固定路径的后面
Route::get('/posts/{slug}', ...);
Route::get('/posts/archive', ...);

当get /posts/archive的时候会被匹配成上面的/posts/{slug}因为wildcard会把/posts/后面的路径都吞掉

@csrf原理是当用户登入的时候伺服器会生成session token，当用户要提交form的时候，伺服器会为同个域名下的form做出回应，所以攻击者没办法架个网站复制form，然后让用户上传资料，这样传过去的request会被那边的伺服器拦截因为伺服器会发现token不一样

可以用在后端用request()来查看前端的form的data有没有传过去后端
request()->validate([]);是拿来validate资料的，可以设置条件比如说密码长度之类的
如果request()->validate([
        'title' => ['required','min:3'],
        'salary' => ['required']
    ]);
前端也用的话就会变成通过前端的required之后进入后端的这个细节required，如果不符合的话就会返回

绕开fillable的方法是用$guarded() = []; 就是在说不需要拦截任何数据注入