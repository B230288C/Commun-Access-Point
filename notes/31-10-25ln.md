if ($job->employer->user->isNot(Auth::user())) {
            abort(403);
        }
这段代码的意思是获取当前job的employer然后再从employer获取user，之后拿来跟现在登录的用户对比，如果不符的话isNot会返回true，if里面的东西就会被运行


Gate::define('edit-job', function (User $user, Job $job) {
            return $job->employer->user->is($user);
        });
Gate::define里的User $user，laravel会自动获取当前登录的用户

Gate::authorize('edit-job', $job);
Gate::authorize会调用Gate::define的结果决定要不要给用户权限

can跟cannot是专门给权限判断的if (auth()->user()->can('edit-job', $job)){ true的话run代码 } ， cannot的话就相反
@can('edit-job', $job)
    <a href="/jobs/{{ $job->id }}/edit">Edit</a>
@endcan
在blade也可以用

Route::get('/jobs/{job}/edit', [JobController::class, 'edit'])->middleware(['auth','can:edit-job,job']);
middleware拿来判断用户有没有登录，有登录就继续运行，如果没登录就不会run这个Route，
第二个参数是当用户通过'auth'，就会运行后面的can

Route::get('/jobs/{job}/edit', [JobController::class, 'edit'])->middleware('auth')->can('edit-job', 'job');
另外一种写法

Gate 简单的全局权限
Policy 针对模型的权限
这两个可以一起用但是不要重复判断

Route::get('test', function () {
    return new \App\Mail\JobPosted();
});
laravel发现这个是Illuminate\Mail\Mailable 的对象的时候会自动把对应的 Blade view 渲染成 HTML，这样可以显示邮件的html内容而不是显示对象结构

mail的发送流程
1 Laravel 运行 Mail::to('jeffrey@laracasts.com')->send(new JobPosted());
2 创建 JobPosted 实例
3 从 JobPosted 获取：
    标题（来自 envelope()）
  内容（来自 content()）
  附件（来自 attachments()）
4.根据 .env 的 mail 设定连接 SMTP（例如 Mailtrap）
5.实际发送邮件

new JobPosted($job)是把$job传进了里面的public function __construct()

queue()跟dispatch()都是把任务放进队列的，queue()是专门给Mailable用的，dispatch()是给处理异步的job,mailable还有notification处理的
这些都是存进队列而已，还没处理存进去的任务，处理任务是交给Worker，启动php artisan queue:work就会处理在队列的任务

logger("里面的内容触发的时候会存进storage里logs的laravel.log");

php 格式自动化 ，先安装composer require laravel/pint --dev，安装好之后运行vendor/bin/pint就会自动帮忙弄好所有php文件的格式
Blade 可用：blade-formatter npx blade-formatter -w resources/views
JS/CSS 可用：Prettier npx prettier --write .

tailwindcss v4之后就没了tailwind.config.js ，全在css文件里面完成